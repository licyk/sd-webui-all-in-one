name: Build All Portable

on:
  schedule:
  # * is a special character in YAML so you have to quote this string
  # UTC 17:00 -> CST (China) 1:00, see https://datetime360.com/cn/utc-cst-china-time/
  # https://docs.github.com/zh/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#schedule
  - cron: '0 16 * * 0'
  workflow_dispatch:

jobs:
  trigger-builds:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger and Monitor build workflows
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const workflows = [
              'build_comfyui.yml',
              'build_fooocus.yml',
              'build_invokeai.yml',
              'build_kohya_gui.yml',
              'build_musubi_tuner.yml',
              'build_qwen_tts_webui.yml',
              'build_sd_next.yml',
              'build_sd_scripts.yml',
              'build_sd_trainer.yml',
              'build_sd_webui_forge_classic.yml',
              'build_sd_webui_forge.yml',
              'build_sd_webui_reforge.yml',
              'build_sd_webui.yml'
            ];

            const delay = 5 * 60 * 1000; // 5 minutes between triggers
            const monitorInterval = 60 * 1000; // 1 minute monitor interval
            const triggeredRuns = new Map(); // workflow_id -> { run_id, status, conclusion }

            async function updateStatus() {
              console.log(`\n--- [${new Date().toISOString()}] 当前工作流执行状态 ---`);
              for (const [workflow, info] of triggeredRuns.entries()) {
                try {
                  const { data: run } = await github.rest.actions.getWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: info.run_id,
                  });
                  info.status = run.status;
                  info.conclusion = run.conclusion;
                  console.log(`- ${workflow}: 状态 [${run.status}], 结果 [${run.conclusion || '进行中'}] (ID: ${info.run_id})`);
                } catch (error) {
                  console.log(`- ${workflow}: 获取状态失败 (${error.message})`);
                }
              }
              console.log('---------------------------------------------------\n');
            }

            // Start background monitoring
            const monitorId = setInterval(async () => {
              if (triggeredRuns.size > 0) {
                await updateStatus();
              }
            }, monitorInterval);

            try {
              for (let i = 0; i < workflows.length; i++) {
                const workflow = workflows[i];
                console.log(`正在触发整合包构建工作流 (${i + 1}/${workflows.length}): ${workflow}`);
                
                try {
                  const startTime = new Date().toISOString();
                  await github.rest.actions.createWorkflowDispatch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow,
                    ref: context.ref,
                  });
                  
                  // Wait a bit for the run to be created
                  await new Promise(r => setTimeout(r, 5000));
                  
                  // Find the latest run for this workflow
                  const { data: runs } = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow,
                    event: 'workflow_dispatch',
                    created: `>=${startTime.split('.')[0]}` // Simple filter
                  });

                  if (runs.workflow_runs.length > 0) {
                    const run = runs.workflow_runs[0];
                    triggeredRuns.set(workflow, { run_id: run.id, status: run.status, conclusion: run.conclusion });
                    console.log(`成功触发并关联: ${workflow} (Run ID: ${run.id})`);
                  } else {
                    console.log(`成功触发 ${workflow}，但未能立即获取到 Run ID`);
                  }

                } catch (error) {
                  console.error(`触发 ${workflow} 失败: ${error.message}`);
                }

                if (i < workflows.length - 1) {
                  console.log(`等待 10 分钟后触发下一个...`);
                  // During the 10 min wait, the interval will keep printing status
                  await new Promise(r => setTimeout(r, delay));
                }
              }

              // Final wait to ensure all triggered workflows finish or at least show final status
              console.log("所有工作流已触发，继续监控 10 分钟...");
              await new Promise(r => setTimeout(r, 10 * 60 * 1000));
              await updateStatus();

            } finally {
              clearInterval(monitorId);
            }
